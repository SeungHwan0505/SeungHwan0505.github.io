# 고급 C# 프로그래밍

### 객체지향

- 객체지향 프로그래밍은 프로그래밍 패러다임 중 하나이다. 
객체지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 
여러개의 독립된 단위인 객체들의 모임으로 파악하고자 하는 것이다.

**객체지향을 사용하는 이유**

- 객체지향 프로그래밍은 **프로그램을 유연하고 변경이 쉽게 만들기 때문에** 대규모 소프트웨어 개발에 많이 사용된다. 객체지향은 절차지향 프로그래밍에 비해 **배우기 더 쉽게 하고** 소프트웨어의  **개발과 유지보수를 더욱 간편하게** 하며 보다 **직관적인 코드 분석을 가능하게 한다**는 장점이 있다.

**유니티에서 상속을 지양하는 이유**

언리얼은 객체지향

---

### **객체 지향 프로그래밍의 4가지 특징 < 추상화, 상속, 다형성, 캡슐화 >**

### **1. 추상화 Abstration**

객체 지향에서 의미하는 추상화란, **객체의 공통적인 속성과 기능 중에서 공통된 부분을 추출하여 하나의 개념으로 정의하는 것**을 의미한다. 

이를 통해 코드를 더욱 단순화 하고 재사용성을 높일 수 있다.

예를들어 자동차와 오토바이라는 이동수단이 존재하고 이 둘은 모두 주행에 필요한 엑셀과 브레이크 동작이 존재한다.  이렇게 주행에 필요한 공통된 동작을 추상화 하여 하나의 개념으로 다루는 것을 추상화 라고 한다.

**추상 클래스(Abstract class)**

C#에서 추상화를 구현하는 방법으로는 먼저 **추상 클래스(Abstract class)**를 사용하는 방법이 있다.
추상클래스는 하나의 **추상 메서드(Abstract Method)**를 포함하는 클래스이다.
**추상 메서드는 기능이 없는 함수**로, 파생 클래스에서 기능을 구현해야 한다.

**추상함수**

- 오버라이딩을 하지 않으면 빌드할 때 에러가 나게된다. 
선언 후 기능은 하위 클래스에서 해주어야 한다
이처럼 **오버라이딩이란 부모에서 정의된 멤버 메서드를 자식에서 재 정의하는 것을 의미한다.**
- **abstract**로 선언이 가능하다.
- 기능이 없는 함수이다.
- C++에서는 순수가상함수라고 한다

**메소드 오버라이딩**

- 메소드 : 일단 함수
- **오버라이딩이란?** 
상속받은 자식 클래스에서 부모 클래스의 메소드를 재정의 하여 상속받은 자식 클래스에서 정의한 메소드가 실행되도록 하는 것

**추상클래스 예시**

```csharp
abstract class Vehicle { // Vehicle이라는 추상 클래스
    public abstract void Drive(); //추상 함수(메서드)
}

//Car과 Motorcycle 이라는 클래스는 Vehicle라는 추상 클래스를 상속받는다.
//그리고 Vehicle의 Drive함수를 각각 구현한다.
class Car : Vehicle {
    public override void Drive() {
        Console.WriteLine("Driving a car");
    }
}

class Motorcycle : Vehicle {
    public override void Drive() {
        Console.WriteLine("Riding a motorcycle");
    }
}
```

**인터페이스 (Interface)**

C#에서 추상화를 구현하는 종류로는 **인터페이스(Interface)**가 있다.
인터페이스는 추상함수들의 모임으로, 클래스를 만들 때 특정 메서드를 반드시 구현해야하는 특징이 있다. 인터페이스를 상속받아 만들어진 클래스는 인터페이스에 명시된 메서드를 반드시 구현해야 한다고 볼 수 있다. 즉, 인터페이스는 클래스의 기능을 정의하는 일종의 템플릿 역할을 한다.

```csharp
// IAnimal 인터페이스 정의
interface IAnimal
{
    void Move(); // 이동 기능을 가지는 메서드
}

//Dog와 Cat 클래스는 IAnimal인터페이스를 구현하고 있으므로 각 클래스글은 반드시
//Move함수를 가지고 있어야 한다.
//Main 함수에서는 IAnimal 타입의 변수 animal1과 animal2를 선언하고, 
//각각 Dog와 Cat 클래스의 인스턴스를 할당하였다. 
//animal1.Move()와 animal2.Move() 호출 시 
//각각 Dog is running.과 Cat is walking.이 출력되는 것을 확인할 수 있다.

****// Dog 클래스가 IAnimal 인터페이스를 구현하는 예시
class Dog : IAnimal
{
    public void Move()
    {
        Console.WriteLine("Dog is running.");
    }
}

// Cat 클래스가 IAnimal 인터페이스를 구현하는 예시
class Cat : IAnimal
{
    public void Move()
    {
        Console.WriteLine("Cat is walking.");
    }
}

// Main 함수에서 IAnimal 인터페이스를 사용한 예시
static void Main(string[] args)
{
    IAnimal animal1 = new Dog();
    IAnimal animal2 = new Cat();
    
    animal1.Move(); // Dog is running.
    animal2.Move(); // Cat is walking.
}
```

추상클래스와 인터페이스 모두 추상화를 이용해 공통된 기능들을 묶어서 재사용 한다는 것을 목적으로 객체지향에서 사용되는 개념이다.

하지만 **추상클래스와 인터페이스는 차이점**이 존재한다.

1. **구현의 유무**
    1. 추상클래스는 일반메서드와 추상메서드를 가질 수 있고, 추상메서드는 자식 클래스에서 구현 해야한다.
    2. 인터페이스는 모든 메서드가 추상메서드로 구현되어 있고,인터페이스를 구현하는 클래스에서 모든 메서드를 구현해야 합니다.
2. **다중 상속**
    1. 추상클래스는 단일 상속만 가능하다.
    2. 인터페이스는 다중 상속이 가능하다.
    
    ```csharp
    // 클래스는 다중 상속 불가능
    public class MyClass : BaseClass, Interface1 // 컴파일 오류 발생
    {
        // 클래스 멤버들
    }
    
    // 인터페이스는 다중 상속 가능
    public class MyClass : Interface1, Interface2 // 다중 상속 가능
    {
        // 인터페이스 멤버들
    }
    ```
    

1. **인스턴스화** (클래스를 기반으로 한 객체(Instance)를 생성하는 작업)
    1. 추상클래스는 인스턴스화가 가능하다.
    아래와 같이 추상클래스 자체를 인스턴스화 할 수 있지만, 추상클래스이기 때문에 직접적으로 인스턴스화가 할 수 없어서 컴파일되지 않는다. 
    따라서 이를 상속받은 자식클래스에서 오버라이딩한 후에 인스턴스화가 가능하다.
    
    ```csharp
    abstract class Animal {
        public abstract void MakeSound();
    }
    
    Animal animal = new Animal();
    ```
    
    1. 인터페이스는 인스턴스화가 불가능하다.
    인터페이스는 인스턴스화 자체가 불가능하다. 직접적으로 인스턴스화를 한 아래와 같은 코드는 컴파일 되지 않는다. 대신 이 인터페이스를 구현한 클래스를 인스턴스화 할 수 있다.
    
    ```csharp
    interface IAnimal {
        void MakeSound();
    }
    
    //불가능, 오류남
    IAnimal animal = new IAnimal(); 
    
    //가능
    class Dog : IAnimal {
        public void MakeSound() {
            Console.WriteLine("Bark!");
        }
    }
    //인스턴스화
    Dog dog = new Dog();
    dog.MakeSound();  // "Bark!" 출력
    ```
    

1. 목적
    1. 추상 클래스는 상속을 통한 다형성 구현에 주로 사용된다.
    2. 인터페이스는 구현 클래스가 특정 인터페이스를 구현하도록 강제되기 때문에  클래스 간의 간섭도를 낮추는데에 사용된다.

이러한 차이점들로 인해, 추상클래스와 인터페이스를 상황에 따라 적합한 선택을 해야한다. 

추상 클래스는 상속을 통해 다른 클래스들이 공통적으로 가지는 속성과 기능을 추상화할 때 주로 사용 된다. 

인터페이스는 클래스 간의 결합도를 낮추고, 특정한 메소드를 필수적으로 구현하도록 강제하는 경우에 사용된다.

### 2. 상속 ****Inheritance****

상속이란 **기존의 클래스를 확장하여 새로운 클래스를 만드는 개념**이다.

상속은 위 개념인 **추상화의 연장선**으로, 클래스간 **공유될 수 있는 속성과 기능들을 상위 클래스로 추상화 하여** 해당 상위 클래스로부터 확장된 여러개의 **하위 클래스들이 모두 상위 클래스의 속성과 기능들을 간편하게 사용할 수 있게된다**. 

상속은 기존 클래스의 속성과 메서드를 새로운 클래스에서 재활용 할 수 있도록 해주는데, 이 때 
기존 클래스를 부모클래스(Parent Class), 상위클래스(super class), 기본클래스(base class) 리고 하고
상속받는 새로운 클래스를 자식클래스(child class), 하위클래스(sub class), 파생클래스(derived class)라고 한다.

**상속을 사용하는 이유**

상속을 통해 클래스 간 반복되는 속성과 기능들을 반복적으로 정의할 필요 없이 딱 한번만 정의 후에 간편하게 재사용할 수 있어 반복적인 코드를 최소화 하고 공유하는 속성과 기능에 간편하게 접근하여 사용할 수 있도록 한다.

### 3. 다형성

기존 다형성의 의미로는 어떤 객체의 속성이나 기능이 상황에 따라 여러가지 형태를 가질 수 있는 것을 의미한다.

객체지향에서의 다형성도 이와 비슷하다. 즉, 이름의 메서드의 속성이나 기능이 그 맥락에 따라 다른 동작을 수행 할 수 있는 객체지향의 특성이다. 
각체들이 같은 이름의 메서드를 호출하더라도 그 동작들이 다를 수 있다.

다형성은 크게 두 가지의 형태로 나뉜다. **오버로딩**과 **오버라이딩** 이다.

**오버로딩**

오버로딩 Overloading 이란 같은 이름의 메서드를 **매개변수의 타입, 개수, 순서** 등을 다르게 정의하여 사용하는 것이다.

아래의 코드를 보면 모두 sum이라는 이름을 가진 메서드이지만, 매개변수의 타입이나 개수가 다르게 정의되었기 때문에 모두 다른 동작을 수행한다.

```csharp
//a + b int형 반환
public int sum(int a, int b) { 
    return a + b;
}

//a + b float형 반환
public float sum(float a, float b) {
    return a + b;
}

//a + b + c int형 봔환
public int sum(int a, int b, int c) {
    return a + b + c;
}
```

이처럼 오버로딩은 매개변수의 타입이나 개수를 다르게하여 같은 이름의 메서드를 정의하는 것으로, 코드의 가독성을 높이고 중복코드를 줄일 수 있다.

**오버라이딩**

오버라이딩은 윗 부분 추상화에서 포함된 개념이다.
상위 클래스에서 정의된 메서드를 하위 클래스에서 재정의하여 사용하는 것을 말한다.
즉, 상위 클래스에 있는 메소드와 같은 이름, 매개변수를 가진 메서드를 하위 클래스에스에서 구현하면, 하위클래스에서 상위클래스의 메서드 대신 해당 메서드가 호출된다. 

오버라이딩은 상속을 기반으로 하기 때문에, 하위 클래스에서 상위 클래스의 메서드를 사용할 수 있지만, 하위클래스에서 상위클래스의 메서드를 더욱 세부적으로 구현하려 할 떄 오버라이딩하여 재정의 할 수 있다. 

아래는 오버라이딩에 대한 코드 예시이다. 
Dog와 Cat은 Animal클래스를 상속받아 오버라이딩 한 MakeSound메서드를 재정의 하여 각각 
"멍멍"과 "야옹"이 출력된다. Animal객체는 오버라이딩 하지 않았기에 "동물 소리"가 출력된다.

```csharp
//virtual은 메서드나 프로퍼티 앞에 사용하여 
//해당 멤버가 파생 클래스에서 재정의 될 수 있음을 의미하는 예약어이다.
//파생클래스에서 override를 통해 재정의 할 수 있다.
//파생 클래스에서 해당 멤버를 오버라이드 하지 않으면 기본 구현이 실행된다.
class Animal {
    public virtual void MakeSound() {
        Console.WriteLine("동물 소리");
    }
}

class Dog : Animal {
    public override void MakeSound() {
        Console.WriteLine("멍멍");
    }
}

class Cat : Animal {
    public override void MakeSound() {
        Console.WriteLine("야옹");
    }
}

class MainClass {
    public static void Main(string[] args) {
        Animal a = new Animal();
        a.MakeSound();  // "동물 소리"

        Dog d = new Dog();
        d.MakeSound();  // "멍멍"

        Cat c = new Cat();
        c.MakeSound();  // "야옹"
    }
}
```

오버라이딩은 위쪽 추상클래스에서도 사용된다. 이 때 일반적인 오버라이딩으로는 **virtual**이라는 예약어를 사용하여 해당 메서드가 파생클래스에서 재정의 될 수 있음을 나타내었다.

추상클래스에서의 오버라이딩은 **abstract**라는 예약어를 사용하였으며, 멤버의 구현이 없음을 나타내는 것이다. abstract라는 예약어가 붙은 멤버는 파생 클래스에서 반드시 구현해야 한다.

### 4. 캡슐화

캡슐화는 클래스 안에 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터들을 외부로부터 보호하는 것을 말한다.

객체지향에서 캡슐화의 이유로는 크게 두가지의 이유가 있다.

1. 데이터 보호 : 외부로부터 클래스에 정의된 속성과 기능들을 보호
2. 데이터 은닉 : 내부의 동작을 감추고 외부에는 필요한 부분만 노출한다.

**캡슐화의 이유**

캡슐화를 통해 **코드를 보호하고 응집도를 높이고 결합도를 낮추는 것을 목표**로 한다.
이를 통해 **코드의 재사용성과 가독성, 유지보수성을 높일 수 있다.**

**응집도** - 하나의 모듈이나 클래스가 자신이 담당하는 기능을 수행하기 위해 관련된 다른 데이터들과 얼마나 밀접하게 연결되어있는지를 나타낸다  

높은 응집도를 가지고 있는 모듈은 하나의 명확한 책임이 있으며, 그 책임들을 수행하기 위한 기능들이 잘 구조화되어있다. 이렇게 하나의 모듈이 자신이 담당하는 책임을 명확하게 수행하고, 다른 모듈과의 의존도를 최소화하면 코드의 유지보수성이 향상되고, 오류 발생 확률이 줄어들며, 코드의 가독성도 높아진다.

**결합도 -** 결합도는 모듈이 다른 모듈과 얼마나 밀접하게 관련되어 있는지를 나타낸다. 즉, 하나의 모델이 다른 모듈에 의존적인 강도를 나타낸다.
결합도가 낮으면 모듈들 간의 의존성이 적어져서 하나의 모듈을 수정하더라도 다른 모듈에 영향을 덜 주게 된다. 따라서 전체적인 시스템의 유지보수나 수정이 용이해지게 된다

인스턴스끼리 캡슐화를 잘 하기 위해 사용되는 개념

- public : 클래스 외부에서 자유롭게 접근 가능하도록 함
- private : 클래스 내부에서만 접근 할 수 있도록 하는 키워드, 즉 상속을 하더라도 파생클래스에서 접근할 수 없다.
- protected : 클래스 내부와 상속받은 클래스만 접근할 수 있도록 하는 키워드. 외부에서는 접근할 수 없다.
- sealed : 상속을 막는 키워드. sealed키워드가 사용된 클래스는 상속받을 수 없고 다른 클래스에 상속할 수 없다.

---

### +단어 개념

**커플링, 디커플링**

**커플링**은 한 객체가 다른 객체와의 의존성 강도를 뜻한다.
두 객체 간의 강한 커플링이 있다면 하나의 객체를 수정하면 다른 객체에도 큰 영향을 미치게 된다.
이는 코드의 유지보수성을 저하시키고 재사용성을 낮추게 된다.

**디커플링**은 커플링의 반대말로서 객체간의 의존성을 최소화하는 것을 의미한다
객체들의 독립적으로 작동하도록 설계하고 한 객체의 수정이 다른객체에 영향이 미치지 않도록 하는 것이다.

**클래스와 인스턴스**

**클래스**는 객체를 만들기 위한 일종의 설계도라고 볼 수 있다. 
클래스는 객체를 만들기 위한 필드의 메서드를 정의하고, 객체를 생성하기 위한 생성자를 제공한다. 
이러한 클래스를 이용하여 만들어진 객체들은 각자의 독립적인 상태와 행동을 가지며 서로 다른 객체끼리는 독립적으로 동작한다.

**인스턴스**는 클래스를 구체화하여 만들어진 객체를 의미한다. 
클래스를 기반으로 만들어진 객체를 인스턴스라고 한다. 이러한 인스턴스는 각각 고유한 속성과 메서드를 가지며, 서로 다른 상태와 기능을 수정 할 수 있다.

클래스를 기반으로 객체를 생성하는 것을 **인스턴스화(instantiation)**라고 하며, 이 과정 이후에 만들어진 객체를 **인스턴스(instance)**라고 한다. 인스턴스는 해당 클래스의 속성과 메소드를 사용할 수 있다.

**형변환**

- 형(Type)을 변환해주는 것이다.
- 프로그래밍에서 생각보다 중요하고 비용도 생각보다 큰 편이다
- 명시적 형변환과 함시적 형변환이 있다
- 일반적인 수치 형변환이 많이 일어난다

**클래스의 형변환**

- **업케스팅**
자식클래스의 객체가 부모클래스의 타입으로 형변환 되는 것을 의미한다.
아래 코드에서 myAnimal 은 Cat타입의 myCat을 가리키지만 
myAnimal  Animal타입이기 때문에 Animal 클래스의 멤버에만 접근이 가능해진다.

```csharp
class Animal {
    public virtual void MakeSound() {
        Console.WriteLine("Animal sound");
    }
}

class Cat : Animal { //Animal클래스를 상속받음
    public override void MakeSound() {
        Console.WriteLine("Meow");
    }
}

class Program {
    static void Main(string[] args) {
        Cat myCat = new Cat(); 
				Animal myAnimal = myCat; //업케스팅

        myAnimal.MakeSound(); // 출력: "Animal sound"
    }
}
```

- **다운캐스팅**
업케스팅과 반대로 형변환 하는 것을 다운캐스팅이라고 한다. 상위 클래스에서 하위클래스로 형변환 하는 것을 말한다. 업케스팅과는 다르게 다운캐스팅 할 때는 타입을 명시적으로 지정해줘야 한다는 차이점이 있다.

```csharp
class Animal {
    public virtual void MakeSound() {
        Console.WriteLine("Animal sound");
    }
}

class Cat : Animal { //Animal클래스를 상속받음
    public override void MakeSound() {
        Console.WriteLine("Meow");
    }
}

class Program {
    static void Main(string[] args) {
        Animal myA = new Cat(); 
				Cat myCat = (Cat)myCat; //다운 케스팅

        myCat .MakeSound(); // 출력: "Meow"
    }
}
```

**네임스페이스 namespace**

네임스페이스란 코드를 구조화하고 편리하게 관리하기 위한 개념으로, 코드의 식별자를 그룹화 할 때 사용하는 일종의 컨테이너 역할을 한다고 볼 수 있다.

네임스페이스를 사용하면 코드를 보다 구조화하고, 클래스나 메서드의 이름 충돌을 방지할 수 있다. 또한 다른 네임스페이스에서 정의한 코드를 참조하여 재사용성을 높일 수 있다. 

**using이라는 키워드**를 통해 다른 네임스페이스에 속한 클래스들을 간편하게 사용할 수 있도록 지원해준다.

**선언과 정의**

- **선언 : declaration**
선언은 변수, 함수, 클래스 등을 사용하기 위해 컴퓨터에 알리는 것을 의미한다. 
즉, 해당 변수, 함수, 클래스의 이름과 자료형 등을 미리 컴퓨터에게 알려주는 것이다. 
선언은 코드 상단에서 보통 이루어딘다.
- **정의 : definition**
정의는 선언된 변수, 함수, 클래스 등을 실제로 구현하는 것을 의미한다. 
즉, 해당 변수, 함수, 클래스가 동작할 수 있도록 코드를 작성하는 것이다. 
정의는 보통 코드의 중간이나 끝에서 이루어진다.

```csharp
int num; //선언
int num = 10; //num선언 후 정의
```

**프로퍼티**

프로퍼티는 속성이라는 의미를 가지고 있다. 프로퍼티를 사용하게 되면, 속성 값을 반환하거나 새 값을 할당 할 수 있다. 
일반적으로 클래스의 필드는 Private로 선언하고 외부에서 접근을 못하게 한다. 그리고 필드에 있는 값을 읽어오거나 설정을 하기 위해서는 프로퍼티의 접근자(Getter)과 설정자(Setter)를 정의하여 외부에서 클래스의 필드값을 조작할 수 있다.

이렇게 프로퍼티를 활용하면 필드 값의 접근을 제어할 수 있고 필드값이 변경될 떄 추가적인 로직을 실행시킬 수 있다.  

```csharp
class MyClass {
    private int myField;

    public int MyProperty {
        get { return myField; } //접근
        set { myField = value; } //수정
    }
}
```